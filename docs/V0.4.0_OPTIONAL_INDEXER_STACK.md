# v0.4.0 Roadmap -- Optional Indexer Stack

**Status:** In Planning
**Target:** Q2 2026
**Estimated Duration:** 6-9 weeks (Phases 1-4)
**Focus:** SQL-based analytics layer for fast queries (consensus-safe, optional)

---

## Executive Summary

### Objective

Provide node operators with an **optional** SQL-based indexing layer for:
- Fast domain/proposal/vote queries
- Analytics dashboards
- Explorer UIs
- Historical data analysis

### Critical Constraint

**ZERO CONSENSUS IMPACT:**
This entire feature set is a read-only projection layer.
If ANY component fails, the blockchain continues unaffected.

### Architecture Principle

```
+-------------------+
|  TrueRepublic     | <-- Consensus Layer (untouched)
|  Chain (Node)     |
+---------+---------+
          | RPC (read-only)
          v
+-------------------+
|    Indexer         | <-- Event Consumer (separate process)
|   (Optional)      |
+---------+---------+
          | Writes
          v
+-------------------+
|   Postgres DB     | <-- Projection (current state + history)
|   (Optional)      |
+---------+---------+
          | Read-only
          v
+-------------------+
|   REST API        | <-- Query Layer (separate process)
|   (Optional)      |
+---------+---------+
          | HTTP
          v
+-------------------+
|    Explorer       | <-- UI (Next.js, read-only)
|   (Optional)      |
+-------------------+
```

**Trust Boundaries:**
- Chain: Consensus-critical
- RPC: Read interface only
- Indexer/DB/API/Explorer: Untrusted, optional

---

## Mandatory Security Requirements

### 1. Consensus Isolation (NON-NEGOTIABLE)

**NO modifications to consensus path:**
- No DB calls in BeginBlocker/EndBlocker
- No DB calls in Msg handlers
- No DB calls in Keepers
- No DB calls in AnteHandler
- No external I/O in deterministic code

**Node independence:**
- `truerepublicd` starts without DB
- `truerepublicd` starts without Indexer
- `truerepublicd` starts without API

**Proof required:**
Delete entire optional stack -- blockchain runs identically.

### 2. Fail-Safe Architecture

**Failure modes (all must be safe):**

| Component Down | Chain Behavior |
|----------------|----------------|
| Postgres | Chain unaffected |
| Indexer | Chain unaffected, retry/backoff |
| API | Chain unaffected, 503 to clients |
| Explorer | Chain unaffected, UI unavailable |

**Resource isolation:**
- Separate processes (no shared memory)
- CPU/memory limits (Docker)
- No process ordering dependency

### 3. Attack Surface Minimization

**API Security:**
- Read-only endpoints (GET only in MVP)
- Rate limiting (IP-based)
- SQL injection prevention (prepared statements)
- CORS allowlist (no wildcard)
- Response size limits
- Timeout enforcement

**DB Security:**
- API user: SELECT only
- Indexer user: INSERT/UPDATE only
- No superuser
- Principle of least privilege

**Future Actions (Phase 5):**
- NOT before external security review
- Threat model required
- Chain-ID verification mandatory
- Anti-phishing UX mandatory

---

## Phase 1: Snapshot Indexer (P0)

### Objective

Build separate indexer service that maintains **current state** snapshots in Postgres.

### Architecture

**Service:** `services/indexer/` (Go binary)
**Input:** Blocks/Tx/Events via RPC or gRPC
**Output:** Postgres tables (current state)
**Idempotency:** Restart-safe via `last_indexed_height`

### Data Model (Postgres Schema)

#### Table: indexer_meta

```sql
CREATE TABLE indexer_meta (
    id INTEGER PRIMARY KEY DEFAULT 1,
    last_indexed_height BIGINT NOT NULL,
    last_indexed_time TIMESTAMP NOT NULL,
    chain_id VARCHAR(255),
    node_id VARCHAR(255),
    CONSTRAINT single_row CHECK (id = 1)
);
```

#### Table: domains

```sql
CREATE TABLE domains (
    domain_id VARCHAR(255) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    metadata JSONB,
    admin_address VARCHAR(255),
    created_height BIGINT NOT NULL,
    updated_height BIGINT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_domains_updated_height ON domains(updated_height);
```

#### Table: domain_memberships

```sql
CREATE TABLE domain_memberships (
    domain_id VARCHAR(255) NOT NULL,
    member_address VARCHAR(255) NOT NULL,
    role VARCHAR(50),
    status VARCHAR(50),
    joined_height BIGINT NOT NULL,
    updated_height BIGINT NOT NULL,
    joined_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    PRIMARY KEY (domain_id, member_address),
    FOREIGN KEY (domain_id) REFERENCES domains(domain_id) ON DELETE CASCADE
);

CREATE INDEX idx_memberships_member ON domain_memberships(member_address);
CREATE INDEX idx_memberships_updated_height ON domain_memberships(updated_height);
```

#### Table: proposals

```sql
CREATE TABLE proposals (
    proposal_id VARCHAR(255) PRIMARY KEY,
    domain_id VARCHAR(255) NOT NULL,
    creator_address VARCHAR(255) NOT NULL,
    title VARCHAR(500),
    description TEXT,
    status VARCHAR(50) NOT NULL,
    voting_mode VARCHAR(50),
    payload JSONB,
    created_height BIGINT NOT NULL,
    updated_height BIGINT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    FOREIGN KEY (domain_id) REFERENCES domains(domain_id) ON DELETE CASCADE
);

CREATE INDEX idx_proposals_domain ON proposals(domain_id);
CREATE INDEX idx_proposals_creator ON proposals(creator_address);
CREATE INDEX idx_proposals_status ON proposals(status);
CREATE INDEX idx_proposals_updated_height ON proposals(updated_height);
```

#### Table: votes

```sql
CREATE TABLE votes (
    proposal_id VARCHAR(255) NOT NULL,
    voter_address VARCHAR(255) NOT NULL,
    rating INTEGER,
    vote_choice VARCHAR(50),
    tx_hash VARCHAR(255),
    height BIGINT NOT NULL,
    voted_at TIMESTAMP NOT NULL,
    PRIMARY KEY (proposal_id, voter_address),
    FOREIGN KEY (proposal_id) REFERENCES proposals(proposal_id) ON DELETE CASCADE
);

CREATE INDEX idx_votes_voter ON votes(voter_address);
CREATE INDEX idx_votes_height ON votes(height);
```

#### Table: proposal_aggregates

```sql
CREATE TABLE proposal_aggregates (
    proposal_id VARCHAR(255) PRIMARY KEY,
    vote_count INTEGER NOT NULL DEFAULT 0,
    total_rating BIGINT NOT NULL DEFAULT 0,
    avg_rating NUMERIC(10,2),
    approval_count INTEGER NOT NULL DEFAULT 0,
    abstain_count INTEGER NOT NULL DEFAULT 0,
    last_updated_height BIGINT NOT NULL,
    last_updated_at TIMESTAMP NOT NULL,
    FOREIGN KEY (proposal_id) REFERENCES proposals(proposal_id) ON DELETE CASCADE
);
```

### Indexing Strategy

**Primary Source:** ABCI Events (pushed)
**Secondary Source:** gRPC Queries (for backfill/repair)

**Algorithm:**

```go
func (idx *Indexer) Run(ctx context.Context) error {
    lastHeight := idx.getLastIndexedHeight()

    for {
        nextHeight := lastHeight + 1

        block, err := idx.rpcClient.Block(ctx, &nextHeight)
        if err != nil {
            time.Sleep(1 * time.Second)
            continue
        }

        results, err := idx.rpcClient.BlockResults(ctx, &nextHeight)
        if err != nil {
            return err
        }

        tx := idx.db.Begin()
        for _, txResult := range results.TxsResults {
            idx.processEvents(tx, txResult.Events, nextHeight)
        }
        tx.Exec("UPDATE indexer_meta SET last_indexed_height = ?, last_indexed_time = ?",
            nextHeight, time.Now())
        tx.Commit()

        lastHeight = nextHeight
        idx.metrics.LastIndexedHeight.Set(float64(lastHeight))
    }
}
```

**Idempotency:**
- Use `INSERT ... ON CONFLICT DO UPDATE` (upserts)
- Height-based guards (`WHERE updated_height < ?`)

**Integrity Check:**
- Optional: Store `block_hash` per height
- Periodic sanity check: Compare random proposals via gRPC

### Docker Integration

```yaml
services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: truerepublic_indexer
      POSTGRES_USER: indexer
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    profiles:
      - indexer

  truerepublic-indexer:
    build: ./services/indexer
    environment:
      INDEXER_ENABLED: ${INDEXER_ENABLED:-false}
      INDEXER_DB_URL: postgres://indexer:password@postgres:5432/truerepublic_indexer
      INDEXER_RPC_URL: http://truerepublic-node:26657
      INDEXER_START_HEIGHT: ${INDEXER_START_HEIGHT:-1}
      INDEXER_MODE: ${INDEXER_MODE:-snapshot}
    depends_on:
      - postgres
      - truerepublic-node
    profiles:
      - indexer

volumes:
  postgres_data:
```

**Activation:**

```bash
# Enable indexer
docker-compose --profile indexer up -d

# Or via env
INDEXER_ENABLED=true docker-compose up -d
```

### Monitoring (Prometheus)

```go
indexer_last_indexed_height          gauge
indexer_lag_blocks                    gauge   // chainHeight - indexedHeight
indexer_events_processed_total       counter
indexer_errors_total                  counter // {type="rpc|db|parse"}
indexer_block_process_duration_seconds histogram
indexer_db_write_duration_seconds     histogram
```

### Tests (15-20)

- Event parsing to model mapping
- Upsert logic (idempotent writes)
- Height tracking (resume after restart)
- Index 100 blocks locally (integration)
- DB down: indexer retries, node unaffected

---

## Phase 2: Full-History Mode (P1, Optional)

### Objective

Optionally store **event history** in addition to current state snapshots.

### Schema Extensions

#### Table: txs

```sql
CREATE TABLE txs (
    tx_hash VARCHAR(255) PRIMARY KEY,
    height BIGINT NOT NULL,
    block_time TIMESTAMP NOT NULL,
    msg_types TEXT[],
    signers TEXT[],
    raw_events JSONB,
    success BOOLEAN NOT NULL
);

CREATE INDEX idx_txs_height ON txs(height);
CREATE INDEX idx_txs_block_time ON txs(block_time);
```

#### Table: domain_membership_events

```sql
CREATE TABLE domain_membership_events (
    id BIGSERIAL PRIMARY KEY,
    domain_id VARCHAR(255) NOT NULL,
    member_address VARCHAR(255) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    old_value JSONB,
    new_value JSONB,
    height BIGINT NOT NULL,
    block_time TIMESTAMP NOT NULL,
    tx_hash VARCHAR(255),
    FOREIGN KEY (domain_id) REFERENCES domains(domain_id) ON DELETE CASCADE
);

CREATE INDEX idx_membership_events_domain ON domain_membership_events(domain_id, height);
CREATE INDEX idx_membership_events_member ON domain_membership_events(member_address, height);
```

#### Table: proposal_events

```sql
CREATE TABLE proposal_events (
    id BIGSERIAL PRIMARY KEY,
    proposal_id VARCHAR(255) NOT NULL,
    domain_id VARCHAR(255) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    payload_delta JSONB,
    height BIGINT NOT NULL,
    block_time TIMESTAMP NOT NULL,
    tx_hash VARCHAR(255),
    FOREIGN KEY (proposal_id) REFERENCES proposals(proposal_id) ON DELETE CASCADE
);

CREATE INDEX idx_proposal_events_proposal ON proposal_events(proposal_id, height);
CREATE INDEX idx_proposal_events_type ON proposal_events(event_type);
```

#### Table: vote_events

```sql
CREATE TABLE vote_events (
    id BIGSERIAL PRIMARY KEY,
    proposal_id VARCHAR(255) NOT NULL,
    voter_address VARCHAR(255) NOT NULL,
    rating INTEGER,
    vote_choice VARCHAR(50),
    height BIGINT NOT NULL,
    block_time TIMESTAMP NOT NULL,
    tx_hash VARCHAR(255) NOT NULL,
    FOREIGN KEY (proposal_id) REFERENCES proposals(proposal_id) ON DELETE CASCADE
);

CREATE INDEX idx_vote_events_proposal ON vote_events(proposal_id, height);
CREATE INDEX idx_vote_events_voter ON vote_events(voter_address, height);
CREATE INDEX idx_vote_events_height ON vote_events(height);
```

### Dual-Write Strategy

In `INDEXER_MODE=full`:
- Write event to history table (append-only)
- Update snapshot table (upsert)

**Idempotency:** Unique constraints `(tx_hash, event_seq)` or dedupe via `(proposal_id, voter_address, height)`.

### Rebuild/Backfill

```bash
# Rebuild from genesis
truerepublic-indexer --rebuild --start-height=1 --end-height=current

# Backfill specific range
truerepublic-indexer --start-height=100000 --end-height=200000

# Reset from height (drop newer data)
truerepublic-indexer --reset-from-height=150000

# Verify consistency
truerepublic-indexer --verify --sample-size=100
```

### Tests (10-15)

- Backfill 200 blocks
- Compare snapshots with gRPC queries
- Reset-from-height, re-index, same results
- Dual-write consistency

---

## Phase 3: Read-Only API (P0)

### Objective

Provide REST API for querying indexed data.

### Service

**Location:** `services/api/` (Go, REST)
**Framework:** Chi router / Gin / Echo (developer's choice)
**OpenAPI:** Auto-generated or manual `openapi.yaml`

### Endpoints (MVP)

#### Health

```
GET /health

Response:
{
  "status": "ok",
  "db": "connected",
  "indexer_height": 123456,
  "chain_height": 123460,
  "lag_blocks": 4
}
```

#### Domains

```
GET /v1/domains?limit=50&cursor=abc&sort=created_desc

Response:
{
  "data": [
    {
      "domain_id": "domain-1",
      "name": "Governance",
      "admin_address": "true1abc...",
      "member_count": 42,
      "proposal_count": 15,
      "created_height": 1000,
      "updated_height": 10000
    }
  ],
  "next_cursor": "xyz",
  "meta": { "total": 120, "limit": 50 }
}
```

```
GET /v1/domains/{domainId}
GET /v1/domains/{domainId}/members?limit=50&role=member&status=active
```

#### Proposals

```
GET /v1/proposals?domain_id=domain-1&status=open&limit=20&sort=updated_desc

Response:
{
  "data": [
    {
      "proposal_id": "prop-1",
      "domain_id": "domain-1",
      "creator_address": "true1abc...",
      "title": "Increase APY to 30%",
      "status": "open",
      "voting_mode": "systemic_consensing",
      "vote_count": 15,
      "created_height": 5000,
      "updated_height": 5100
    }
  ],
  "next_cursor": "xyz"
}
```

```
GET /v1/proposals/{proposalId}
GET /v1/proposals/{proposalId}/votes?limit=100
GET /v1/proposals/{proposalId}/aggregate
```

#### Accounts (Optional MVP+)

```
GET /v1/accounts/{address}/domains
GET /v1/accounts/{address}/votes?limit=50
```

#### Full-History Endpoints (Phase 2)

```
GET /v1/proposals/{proposalId}/events
GET /v1/domains/{domainId}/members/{address}/events
GET /v1/txs/{txHash}
```

### Security

**Rate Limiting:**

```go
middleware := httprate.LimitByIP(100, 1*time.Minute)
router.Use(middleware)
```

**CORS:**

```go
cors := cors.New(cors.Options{
    AllowedOrigins: []string{
        "https://explorer.truerepublic.io",
        "http://localhost:3000",
    },
    AllowedMethods: []string{"GET", "OPTIONS"},
    AllowedHeaders: []string{"Accept", "Content-Type"},
})
router.Use(cors.Handler)
```

**SQL Injection Prevention:**

```go
// ALWAYS use prepared statements
func (db *DB) GetProposal(id string) (*Proposal, error) {
    var p Proposal
    err := db.QueryRow(
        "SELECT * FROM proposals WHERE proposal_id = $1",
        id,
    ).Scan(&p)
    return &p, err
}
```

**Response Size Limit:**

```go
const MaxPageSize = 200

func validateLimit(limit int) int {
    if limit <= 0 || limit > MaxPageSize {
        return 50
    }
    return limit
}
```

### Docker Integration

```yaml
truerepublic-api:
  build: ./services/api
  environment:
    API_ENABLED: ${API_ENABLED:-false}
    API_DB_URL: postgres://api_readonly:password@postgres:5432/truerepublic_indexer
    API_PORT: 8080
    API_CORS_ORIGINS: https://explorer.truerepublic.io,http://localhost:3000
    API_RATE_LIMIT_RPS: 100
  ports:
    - "8080:8080"
  depends_on:
    - postgres
  profiles:
    - api
```

**DB User (Read-Only):**

```sql
CREATE USER api_readonly WITH PASSWORD 'secure_password';
GRANT CONNECT ON DATABASE truerepublic_indexer TO api_readonly;
GRANT USAGE ON SCHEMA public TO api_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO api_readonly;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO api_readonly;
```

### Tests (8-10)

- Handler tests (mock DB)
- Pagination logic
- Filter validation
- Smoke tests: /health, /v1/domains, /v1/proposals
- Rate limiting verification

---

## Phase 4: Minimal Explorer (P1)

### Objective

Build read-only frontend for browsing domains, proposals, and votes.

### Tech Stack

- **Framework:** Next.js 14 (App Router)
- **Language:** TypeScript
- **Styling:** Tailwind CSS
- **Data Fetching:** SWR or React Query
- **Deployment:** Static export or Docker

### Pages

| Route | Description |
|-------|-------------|
| `/` | Dashboard: KPI cards, recent proposals, indexer lag warning |
| `/domains` | Domain list with search, filter, pagination |
| `/domains/[domainId]` | Domain detail with members and proposals tabs |
| `/proposals` | Proposal list with domain/status/creator filters |
| `/proposals/[proposalId]` | Proposal detail with aggregate stats and vote table |

### Components

**Reusable:**
- `SearchBar`, `FilterPanel`, `DataTable` (sorting, pagination)
- `Pagination`, `StatusBadge` (color-coded), `CopyAddress`
- `LoadingSpinner`, `ErrorBoundary`

### API Client

```typescript
// lib/api.ts
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8080';

export async function getDomains(params: {
  limit?: number;
  cursor?: string;
  sort?: string;
}): Promise<PaginatedResponse<Domain>> {
  const url = new URL('/v1/domains', API_BASE_URL);
  Object.entries(params).forEach(([k, v]) => {
    if (v) url.searchParams.append(k, String(v));
  });
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}
```

### Types

```typescript
// lib/types.ts
export interface Domain {
  domain_id: string;
  name: string;
  admin_address: string;
  member_count: number;
  proposal_count: number;
  created_height: number;
  updated_height: number;
}

export interface Proposal {
  proposal_id: string;
  domain_id: string;
  creator_address: string;
  title: string;
  description: string;
  status: 'open' | 'closed' | 'executed';
  voting_mode: 'systemic_consensing' | 'simple_majority' | 'absolute_majority';
  vote_count: number;
  created_height: number;
  updated_height: number;
}

export interface Vote {
  voter_address: string;
  rating?: number;
  vote_choice?: 'approve' | 'abstain';
  height: number;
  voted_at: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  next_cursor?: string;
  meta: { total?: number; limit: number };
}
```

### Docker Integration

```yaml
truerepublic-explorer:
  build: ./services/explorer
  environment:
    NEXT_PUBLIC_API_BASE_URL: http://truerepublic-api:8080
    EXPLORER_ENABLED: ${EXPLORER_ENABLED:-false}
  ports:
    - "3000:3000"
  depends_on:
    - truerepublic-api
  profiles:
    - explorer
```

### Security Constraints (MVP)

**NO wallet integration** (no Keplr, no Leap, no MetaMask).
**NO action buttons** (no "Create Proposal", no "Vote", no "Join Domain").
**READ-ONLY ONLY** -- all data displayed is from API (read-only).

**Laggy Data Warning:**

```tsx
{lag > 10 && (
  <Alert severity="warning">
    Indexer is {lag} blocks behind. Data may be outdated.
  </Alert>
)}
```

### Tests (5)

- Component tests (React Testing Library)
- API client mocking
- Playwright smoke: /, /domains, /proposals return 200

---

## Phase 5: Wallet Actions (P2, Security Review Required)

### CRITICAL SECURITY GATE

**This phase is BLOCKED until:**
1. External security review completed
2. Threat model approved
3. UX security requirements defined
4. Chain-ID verification implemented
5. Anti-phishing measures implemented

### Scope (If Approved)

**Wallet Integration:** Keplr (primary), Leap (secondary)

**Actions:**
- Create Proposal
- Cast Vote (Systemic Consensing / Simple Majority)
- Join Domain (if permitted)

**Security Requirements:**

```tsx
// Chain-ID Verification
const chainId = await keplr.getChainId();
if (chainId !== 'truerepublic-1') {
  throw new Error('Wrong chain! Expected truerepublic-1');
}

// Message Preview (mandatory)
<MessagePreview>
  <h3>You are about to sign:</h3>
  <pre>{JSON.stringify(msg, null, 2)}</pre>
  <p>Chain: {chainId}</p>
  <p>Fee: {fee.amount} {fee.denom}</p>
</MessagePreview>
```

**No Auto-Broadcast:** User must explicitly confirm after signing.

### Tests (20+)

- Mock wallet connection, sign message, broadcast TX
- Error handling (wrong chain, rejected signature)
- Manual: Real wallet test on testnet

---

## 10-Point Threat Model

Developer must fill out this template before ANY code is deployed.

### 1. Consensus Coupling Risk

| | |
|---|---|
| **Risk** | Indexer/API/DB indirectly affects consensus |
| **Impact** | CRITICAL |
| **Likelihood** | LOW (if architecture followed) |
| **Mitigation** | Separate processes, no shared memory, node starts without DB, resource limits |
| **Residual Risk** | MINIMAL |

### 2. RPC DoS / Rate Exhaustion

| | |
|---|---|
| **Risk** | Indexer aggressive queries overwhelm node RPC |
| **Impact** | HIGH |
| **Likelihood** | MEDIUM |
| **Mitigation** | Concurrency cap (max 5), exponential backoff, max 10 QPS, graceful retry |
| **Residual Risk** | LOW |

### 3. DB Growth / Disk Exhaustion

| | |
|---|---|
| **Risk** | Full-history mode fills disk uncontrollably |
| **Impact** | MEDIUM |
| **Likelihood** | MEDIUM (if no retention policy) |
| **Mitigation** | Snapshot mode default, disk monitoring alerts, growth projection, optional partitioning |
| **Residual Risk** | LOW |

### 4. Data Integrity Corruption

| | |
|---|---|
| **Risk** | Indexer crashes mid-block, partial writes |
| **Impact** | MEDIUM |
| **Likelihood** | MEDIUM |
| **Mitigation** | Idempotent upserts, transaction per block, resume from last_indexed_height, block hash checkpointing |
| **Residual Risk** | LOW |

### 5. Silent Divergence from Chain State

| | |
|---|---|
| **Risk** | DB shows wrong data, no one notices |
| **Impact** | HIGH |
| **Likelihood** | LOW (if verified) |
| **Mitigation** | Periodic sanity check (random sample vs gRPC), block hash verification, "out of sync" flag, manual verify command |
| **Residual Risk** | MEDIUM |

### 6. SQL Injection / API Exploits

| | |
|---|---|
| **Risk** | Malicious query params compromise DB |
| **Impact** | CRITICAL |
| **Likelihood** | LOW (if coded correctly) |
| **Mitigation** | Prepared statements ONLY, strict query builder, input validation, rate limiting, response timeout |
| **Residual Risk** | MINIMAL |

### 7. Resource Exhaustion via Public API

| | |
|---|---|
| **Risk** | API spam exhausts CPU/memory |
| **Impact** | MEDIUM |
| **Likelihood** | HIGH (if public) |
| **Mitigation** | Mandatory pagination (max 200), response size limit, rate limiting per IP, slow query logging, caching hot endpoints |
| **Residual Risk** | LOW |

### 8. CORS / Browser Exploitation

| | |
|---|---|
| **Risk** | API abused by arbitrary origins |
| **Impact** | MEDIUM |
| **Likelihood** | MEDIUM |
| **Mitigation** | Explicit origin allowlist, no wildcard CORS, rate limiting, no credentials mode |
| **Residual Risk** | LOW |

### 9. Privilege Escalation (DB)

| | |
|---|---|
| **Risk** | API user modifies data |
| **Impact** | HIGH |
| **Likelihood** | LOW (if permissions set) |
| **Mitigation** | Read-only DB user for API (SELECT only), separate credentials for indexer, principle of least privilege, audit logs |
| **Residual Risk** | MINIMAL |

### 10. Future Wallet/Action Surface

| | |
|---|---|
| **Risk** | Phase 5 introduces phishing, wrong-chain signing, replay |
| **Impact** | CRITICAL |
| **Likelihood** | HIGH (if not reviewed) |
| **Mitigation** | Chain-ID verification mandatory, message preview, security review BEFORE deployment, anti-phishing UX, no auto-broadcast |
| **Residual Risk** | MEDIUM (even with review) |

---

## Test Strategy

### Coverage Target

| Phase | Tests |
|-------|-------|
| Phase 1: Snapshot Indexer | 15-20 |
| Phase 2: Full-History Mode | 10-15 |
| Phase 3: Read-Only API | 8-10 |
| Phase 4: Minimal Explorer | 5 |
| Phase 5: Wallet Actions | 20+ |
| **Total** | **~60-70** |

### Test Types

- **Unit:** Event parsing, model mapping, handler logic, API validation
- **Integration:** Index 100 blocks (verify snapshots), query against seeded DB, Playwright smoke tests
- **E2E:** Full stack: Indexer + API + Explorer + Chain

### Failure Simulation (Required)

- DB down: Indexer retries, node unaffected
- RPC down: Indexer backoff, node unaffected
- API overload: Rate limited
- Disk full: Indexer fails gracefully
- Corrupt row: Rebuild possible

---

## Deliverables

### Code Structure

```
services/
+-- indexer/
|   +-- cmd/indexer/main.go
|   +-- internal/
|   |   +-- indexer/indexer.go, events.go, models.go
|   |   +-- db/postgres.go, queries.go
|   |   +-- metrics/prometheus.go
|   +-- migrations/
|   |   +-- 001_create_tables.up.sql
|   |   +-- 001_create_tables.down.sql
|   +-- Dockerfile
|   +-- README.md
|
+-- api/
|   +-- cmd/api/main.go
|   +-- internal/
|   |   +-- handlers/domains.go, proposals.go, votes.go
|   |   +-- db/queries.go
|   |   +-- middleware/ratelimit.go, cors.go
|   +-- openapi.yaml
|   +-- Dockerfile
|   +-- README.md
|
+-- explorer/
    +-- app/
    |   +-- page.tsx
    |   +-- domains/page.tsx, [domainId]/page.tsx
    |   +-- proposals/page.tsx, [proposalId]/page.tsx
    +-- lib/api.ts, types.ts
    +-- components/DataTable.tsx, Pagination.tsx, StatusBadge.tsx
    +-- Dockerfile
    +-- README.md
```

### Documentation

- `docs/V0.4.0_OPTIONAL_INDEXER_STACK.md` (this document)
- `services/indexer/README.md` (setup, backfill, troubleshooting)
- `services/api/README.md` (endpoints, examples)
- `services/explorer/README.md` (dev setup)
- `services/api/openapi.yaml` (API spec)

### Wiki Pages

- `develop/Optional-Indexer-Architecture.md`
- `operators/Indexer-Setup-Guide.md`
- `users/Explorer-Guide.md`

---

## Acceptance Criteria

v0.4.0 is DONE when:

**Functionality:**
- [ ] Indexer syncs from genesis to current height
- [ ] Indexer resumes correctly after restart
- [ ] DB queries return correct snapshots
- [ ] API endpoints work (all MVP routes)
- [ ] Explorer UI displays data correctly

**Security:**
- [ ] Node runs identically with/without indexer
- [ ] DB failure: zero chain impact
- [ ] API failure: zero chain impact
- [ ] No consensus path dependencies
- [ ] 10-point threat model completed
- [ ] Read-only DB user verified

**Tests:**
- [ ] 60-70 tests passing (all phases)
- [ ] Failure simulations pass (DB/RPC/API down)
- [ ] Load test: API handles 100 RPS

**Documentation:**
- [ ] Full spec complete
- [ ] Runbooks written
- [ ] OpenAPI spec published
- [ ] Wiki updated

**Deployment:**
- [ ] Docker Compose works (`--profile indexer`)
- [ ] Prometheus metrics exposed
- [ ] Grafana dashboard (optional)

---

## Post-v0.4.0

**v0.5.0 -- DEX Expansion:**
- BTC/ETH/LUSD pools via IBC
- Optional: Full-History Mode completion

**v1.0.0 -- Production:**
- External audit (include Indexer Stack)
- Mainnet launch
- Optional: Wallet Actions (Phase 5, AFTER security review)

---

**End of v0.4.0 Specification**
